<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Isla Calavera - Contador</title>
  <style>
    :root{
      --bg1:#0f0f23; --bg2:#16213e; --bg3:#1a1a2e;
      --card:rgba(255,255,255,.10);
      --card2:rgba(0,0,0,.35);
      --b:rgba(255,255,255,.18);
      --gold:#ffd700;
      --orange:#ff6b35;
      --good:#00cc6a;
      --bad:#ff4444;
      --txt:#f0f0f0;
      --muted:#b0b0b0;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      min-height:100vh;
      background:linear-gradient(135deg,var(--bg3) 0%,var(--bg2) 50%,var(--bg1) 100%);
      color:var(--txt);
    }
    .container{max-width:1100px;margin:0 auto;padding:16px}
    header{
      text-align:center;margin:10px 0 18px;
      padding:16px;border-radius:14px;background:rgba(0,0,0,.3);
      border:1px solid rgba(255,255,255,.12);
      box-shadow:0 8px 32px rgba(0,0,0,.4);
    }
    h1{
      font-size:2.15rem;
      background:linear-gradient(45deg,var(--gold),#ffed4e,var(--orange));
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;
      margin-bottom:6px;
    }
    .subtitle{color:var(--muted)}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .card{
      background:var(--card);
      border:1px solid var(--b);
      backdrop-filter: blur(10px);
      border-radius:14px;
      padding:14px;
      box-shadow:0 8px 22px rgba(0,0,0,.28);
    }
    .card h2{font-size:1.1rem;margin-bottom:10px;color:var(--gold)}
    .btn{
      appearance:none;border:0;cursor:pointer;
      padding:11px 16px;border-radius:999px;
      font-weight:700;font-size:1rem;
      box-shadow:0 5px 18px rgba(0,0,0,.25);
      transition:transform .12s ease, filter .12s ease;
      user-select:none;
    }
    .btn:active{transform:translateY(1px)}
    .btn-primary{background:linear-gradient(45deg,var(--gold),#ffed4e);color:#1a1a2e}
    .btn-secondary{background:linear-gradient(45deg,var(--orange),#f7931e);color:#111}
    .btn-ghost{background:rgba(255,255,255,.10);color:var(--txt);border:1px solid var(--b)}
    .btn-danger{background:linear-gradient(45deg,#6c757d,#495057);color:#fff}
    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap:12px;
    }
    label{display:block;font-size:.92rem;color:var(--muted);margin:10px 0 6px}
    input[type="text"], select{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--b);
      background:rgba(0,0,0,.38);
      color:var(--txt);
      outline:none;
    }
    input[type="text"]:focus, select:focus{border-color:rgba(255,215,0,.75);box-shadow:0 0 0 2px rgba(255,215,0,.20)}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      background:rgba(0,0,0,.32);border:1px solid rgba(255,255,255,.10);
      color:var(--txt);
      font-weight:650;
    }
    .pill small{color:var(--muted);font-weight:600}
    .score{
      font-size:1.9rem;font-weight:900;
      background:linear-gradient(45deg,#00ff88,var(--good));
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;
    }
    .muted{color:var(--muted)}
    .notice{padding:10px 12px;border-radius:12px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.10)}
    .notice.good{border-color:rgba(0,204,106,.35)}
    .notice.bad{border-color:rgba(255,68,68,.35)}
    .divider{height:1px;background:rgba(255,255,255,.10);margin:12px 0}
    .kv{display:flex;justify-content:space-between;gap:12px;margin:6px 0}
    .kv b{color:var(--txt)}
    .counter{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px;border-radius:12px;background:rgba(0,0,0,.28);border:1px solid rgba(255,255,255,.10);
    }
    .counter .name{font-weight:800}
    .counter .sub{font-size:.85rem;color:var(--muted)}
    .counter .ctl{display:flex;align-items:center;gap:8px}
    .mini{
      width:36px;height:36px;border-radius:10px;border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.10);color:var(--txt);
      font-size:1.1rem;font-weight:900;cursor:pointer;
    }
    .mini:active{transform:translateY(1px)}
    .num{
      min-width:32px;text-align:center;font-weight:900;font-size:1.05rem;
    }
    .modal{
      position:fixed;inset:0;display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,.55);padding:18px;z-index:9999;
    }
    .modal .box{
      width:min(560px, 100%);
      background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(0,0,0,.35));
      border:1px solid rgba(255,255,255,.18);
      border-radius:18px;
      padding:18px;
      box-shadow:0 20px 50px rgba(0,0,0,.6);
    }
    .modal h3{color:var(--gold);margin-bottom:8px}
    .right{display:flex;justify-content:flex-end;gap:10px;flex-wrap:wrap}
    .small{font-size:.92rem}

    /* Bot√≠n */
    .checkrow{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px;border-radius:12px;background:rgba(0,0,0,.28);border:1px solid rgba(255,255,255,.10)}
    .checkrow .lhs{display:flex;align-items:center;gap:10px}
    .checkrow input[type="checkbox"]{transform:scale(1.25)}
    .tag{font-size:.85rem;color:var(--muted)}
    @media (max-width: 720px){
      h1{font-size:1.85rem}
      .container{padding:12px}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üè¥‚Äç‚ò†Ô∏è Isla Calavera</h1>
      <div class="subtitle">Contador de puntuaci√≥n con cartas y dados (2‚Äì5 jugadores)</div>
    </header>

    <main id="app"></main>
  </div>

  <div class="modal" id="modal">
    <div class="box">
      <h3 id="modalTitle"></h3>
      <div id="modalBody" class="small muted"></div>
      <div class="divider"></div>
      <div class="right">
        <button class="btn btn-ghost" id="modalCancel">Cancelar</button>
        <button class="btn btn-primary" id="modalOk">Aceptar</button>
      </div>
    </div>
  </div>

<script>
/**
 * Reglas base seg√∫n reglamento ES [page:1].
 * Bot√≠n: si sale 3a calavera, turno acaba y s√≥lo punt√∫an los dados ya colocados en la carta [page:1].
 * Con flujo ‚Äúresultado final‚Äù, modelamos Bot√≠n como selecci√≥n manual de qu√© dados estaban guardados.
 */

const DICE_TYPES = [
  { key:'skull', label:'Calavera', emoji:'üíÄ', max:8 },
  { key:'saber', label:'Sable', emoji:'üó°Ô∏è', max:8 },
  { key:'monkey', label:'Mono', emoji:'üêí', max:8 },
  { key:'parrot', label:'Loro', emoji:'ü¶ú', max:8 },
  { key:'gold', label:'Moneda', emoji:'ü™ô', max:8 },
  { key:'diamond', label:'Diamante', emoji:'üíé', max:8 },
];

const FORTUNE = [
  { key:'none', label:'Sin carta / Normal' },
  { key:'pirate', label:'Pirata (duplica puntos; Isla Calavera -200 por calavera)' },
  { key:'animals', label:'Animales (Monos+Loros combinan juntos)' },
  { key:'gold', label:'Moneda de Oro (+1 moneda al inicio)' },
  { key:'diamond', label:'Diamante (+1 diamante al inicio)' },
  { key:'skull1', label:'Calavera (+1 calavera al inicio; no hay bono)' },
  { key:'skull2', label:'Calavera (+2 calaveras al inicio; no hay bono)' },
  { key:'sorceress', label:'Hechicera (sin efecto en modo ‚Äúresultado final‚Äù)' },
  { key:'ship2', label:'Barco Pirata (>=2 sables: +300; si no, -300)' },
  { key:'ship3', label:'Barco Pirata (>=3 sables: +500; si no, -500)' },
  { key:'ship4', label:'Barco Pirata (>=4 sables: +1000; si no, -1000)' },
  { key:'chest', label:'Bot√≠n (selecciona qu√© dados estaban guardados)' },
];

const SET_POINTS = { 3:100, 4:200, 5:500, 6:1000, 7:2000, 8:4000 };
const TARGET_SCORE = 6000;

function clampScore(mode, score){
  if (mode === 'hardcore') return score;
  return Math.max(0, score);
}

function randInt(n){ return Math.floor(Math.random() * n); }

function modalConfirm({title, body, okText='Aceptar', cancelText='Cancelar'}){
  return new Promise(resolve => {
    const modal = document.getElementById('modal');
    const t = document.getElementById('modalTitle');
    const b = document.getElementById('modalBody');
    const ok = document.getElementById('modalOk');
    const cancel = document.getElementById('modalCancel');

    t.textContent = title;
    b.textContent = body;
    ok.textContent = okText;
    cancel.textContent = cancelText;

    const cleanup = (v) => {
      ok.onclick = null; cancel.onclick = null;
      modal.style.display = 'none';
      resolve(v);
    };
    ok.onclick = () => cleanup(true);
    cancel.onclick = () => cleanup(false);
    modal.style.display = 'flex';
  });
}

function initDiceCounts(){
  return { skull:0, saber:0, monkey:0, parrot:0, gold:0, diamond:0 };
}
function totalDice(d){ return Object.values(d).reduce((a,b)=>a+b,0); }
function cryptoRandomId(){
  try{
    const a = new Uint32Array(2);
    crypto.getRandomValues(a);
    return `${a[0].toString(16)}${a[1].toString(16)}`;
  }catch{
    return Math.random().toString(16).slice(2);
  }
}
function escapeHtml(s){
  return String(s)
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}

function applyFortuneBaseDice(fortuneKey){
  const base = initDiceCounts();
  if (fortuneKey === 'gold') base.gold += 1;
  if (fortuneKey === 'diamond') base.diamond += 1;
  if (fortuneKey === 'skull1') base.skull += 1;
  if (fortuneKey === 'skull2') base.skull += 2;
  return base;
}
function mergeDice(base, picked){
  const out = initDiceCounts();
  for (const k of Object.keys(out)){
    out[k] = (base[k]||0) + (picked[k]||0);
  }
  return out;
}

// NUEVO: Bot√≠n seleccionado (n√∫mero por tipo) y validaci√≥n
function validateChestSelection(finalDice, chestDice){
  // chestDice no puede exceder finalDice por tipo, y el total de chestDice no puede exceder 8
  let ok = true;
  let reasons = [];
  let sum = 0;
  for (const k of Object.keys(finalDice)){
    const cv = chestDice[k] || 0;
    const fv = finalDice[k] || 0;
    sum += cv;
    if (cv < 0 || !Number.isFinite(cv)) { ok=false; reasons.push('Selecci√≥n de Bot√≠n inv√°lida.'); break; }
    if (cv > fv){
      ok=false;
      reasons.push(`Bot√≠n: has marcado m√°s "${k}" de los que han salido.`);
      break;
    }
  }
  if (sum > 8){
    ok=false;
    reasons.push('Bot√≠n: no puede haber m√°s de 8 dados.');
  }
  return { ok, sum, reasons };
}

// Computa puntos para un set de dados FINAL (ya incluye bonus de carta si procede)
function computePointsFromDice(mode, fortuneKey, allDiceCounts){
  // Devuelve { points, fullChestBonus, shipBonusOrPenalty, pirateMultiplier, bust, notes[] }
  const notes = [];
  const d = {...allDiceCounts};

  const skullsTotal = d.skull;
  const bust = skullsTotal >= 3;

  const pirateMultiplier = (fortuneKey === 'pirate') ? 2 : 1;

  // Isla Calavera se gestiona fuera (es flujo aparte) [page:1].
  // Aqu√≠ s√≥lo puntuaci√≥n normal.
  if (bust){
    return {
      points: 0,
      fullChestBonus: 0,
      shipBonusOrPenalty: 0,
      pirateMultiplier,
      bust: true,
      notes: ['3+ calaveras: el turno normal punt√∫a 0.']
    };
  }

  // face value
  let faceValue = (d.gold + d.diamond) * 100;

  const setTypes = [];
  if (fortuneKey === 'animals'){
    const animals = d.monkey + d.parrot;
    setTypes.push({ key:'animals', n: animals });
    notes.push('Carta Animales: monos+loros combinan en un √∫nico set.');
  } else {
    setTypes.push({ key:'monkey', n: d.monkey });
    setTypes.push({ key:'parrot', n: d.parrot });
  }
  setTypes.push({ key:'saber', n: d.saber });
  setTypes.push({ key:'gold', n: d.gold });
  setTypes.push({ key:'diamond', n: d.diamond });

  let setScore = 0;
  for (const t of setTypes){
    if (t.n >= 3){
      setScore += SET_POINTS[t.n] || 0;
    }
  }

  // Barco Pirata [page:1]
  let shipReq = null;
  let shipValue = 0;
  if (fortuneKey === 'ship2'){ shipReq = 2; shipValue = 300; }
  if (fortuneKey === 'ship3'){ shipReq = 3; shipValue = 500; }
  if (fortuneKey === 'ship4'){ shipReq = 4; shipValue = 1000; }

  let shipBonusOrPenalty = 0;
  if (shipReq !== null){
    if (d.saber >= shipReq){
      shipBonusOrPenalty = shipValue;
      notes.push(`Barco Pirata: cumples ${shipReq} sables, +${shipValue}.`);
    } else {
      shipBonusOrPenalty = -shipValue;
      notes.push(`Barco Pirata: no llegas a ${shipReq} sables, 0 puntos y -${shipValue}.`);
      const p = clampScore(mode, shipBonusOrPenalty * pirateMultiplier);
      return { points: p, fullChestBonus: 0, shipBonusOrPenalty, pirateMultiplier, bust:false, notes };
    }
  }

  // Cofre completo +500: ‚Äúanotar con cada uno de los ocho dados‚Äù; y ‚Äúcon una calavera no hay bonificaci√≥n‚Äù [page:1].
  let fullChestBonus = 0;
  const anyPoints = (faceValue + setScore + Math.max(0, shipBonusOrPenalty)) > 0;
  // En nuestro modelo de "resultado final", consideramos cofre completo si:
  // - no hay calaveras
  // - hay puntos
  // Nota: en Bot√≠n se recalcula aparte.
  if (d.skull === 0 && anyPoints){
    fullChestBonus = 500;
    notes.push('Cofre completo: +500.');
  }

  let points = (faceValue + setScore + fullChestBonus + shipBonusOrPenalty) * pirateMultiplier;

  // Carta Calavera: sin bono [page:1] => anulamos cofre completo si existiera.
  if ((fortuneKey === 'skull1' || fortuneKey === 'skull2') && fullChestBonus > 0){
    points -= fullChestBonus * pirateMultiplier;
    fullChestBonus = 0;
    notes.push('Carta Calavera: no hay bono de cofre completo.');
  }

  return { points, fullChestBonus, shipBonusOrPenalty, pirateMultiplier, bust:false, notes };
}

// Turn compute (para UI) con dados f√≠sicos + carta
function computeTurn(mode, fortuneKey, physicalDice){
  const notes = [];
  const baseFromCard = applyFortuneBaseDice(fortuneKey);
  const all = mergeDice(baseFromCard, physicalDice);

  const diceTotal = totalDice(physicalDice);
  const skullsTotal = all.skull;

  const canConfirm = diceTotal === 8;

  const computed = {
    canConfirm,
    totalDice: diceTotal,
    skullsTotal,
    points: 0,
    fullChestBonus: 0,
    shipBonusOrPenalty: 0,
    pirateMultiplier: (fortuneKey === 'pirate') ? 2 : 1,
    notes,
    bust: skullsTotal >= 3,
    canSkullIsland: false,
    skullIslandBaseSkulls: 0,

    // nuevo: info para bot√≠n
    allDice: all,
  };

  // Isla Calavera: 4+ calaveras en primera tirada con 8 dados [page:1].
  // En resultado final la activamos cuando ya hay 8 dados f√≠sicos confirmados.
  if (canConfirm && skullsTotal >= 4){
    computed.canSkullIsland = true;
    computed.skullIslandBaseSkulls = skullsTotal;
    computed.points = 0;
    notes.push('Isla Calavera activada: los dem√°s s√≠mbolos no punt√∫an.');
    return computed;
  }

  if (!canConfirm){
    notes.push(`Selecciona ${8 - diceTotal} dado(s) m√°s para confirmar.`);
    return computed;
  }

  // Puntuaci√≥n normal (si no es isla calavera)
  const normal = computePointsFromDice(mode, fortuneKey, all);
  computed.points = normal.points;
  computed.fullChestBonus = normal.fullChestBonus;
  computed.shipBonusOrPenalty = normal.shipBonusOrPenalty;
  notes.push(...normal.notes);

  return computed;
}

function computeSkullIslandPenaltyPerSkull(fortuneKey){
  if (fortuneKey === 'pirate') return 200;
  return 100;
}

// Estado
const state = {
  screen: 'setup',
  mode: 'normal',
  numPlayers: 2,
  players: [],
  currentPlayerIndex: 0,
  round: 1,
  finalPhase: null,
  winnerId: null,

  turn: {
    fortune: 'none',
    dice: initDiceCounts(),        // dados f√≠sicos (8)
    chest: initDiceCounts(),       // NUEVO: dados marcados como Bot√≠n (subconjunto de allDice)
    computed: null
  },

  skullIsland: { collectedSkulls: 0 }
};

function resetToSetup(){
  state.screen = 'setup';
  state.mode = 'normal';
  state.numPlayers = 2;
  state.players = [];
  state.currentPlayerIndex = 0;
  state.round = 1;
  state.finalPhase = null;
  state.winnerId = null;

  state.turn.fortune = 'none';
  state.turn.dice = initDiceCounts();
  state.turn.chest = initDiceCounts();
  state.turn.computed = computeTurn(state.mode, state.turn.fortune, state.turn.dice);

  state.skullIsland.collectedSkulls = 0;
  render();
}

function startNamesScreen(){
  state.players = Array.from({length: state.numPlayers}, (_, i) => ({
    id: cryptoRandomId(),
    name: `Pirata ${String.fromCharCode(65+i)}`,
    score: 0
  }));
  state.screen = 'names';
  render();
}

function beginGame(){
  state.currentPlayerIndex = randInt(state.players.length);
  state.round = 1;
  state.finalPhase = null;
  startTurn();
}

function startTurn(){
  state.screen = 'turn';
  state.turn.fortune = 'none';
  state.turn.dice = initDiceCounts();
  state.turn.chest = initDiceCounts();
  state.turn.computed = computeTurn(state.mode, state.turn.fortune, state.turn.dice);
  render();
}

function setFortune(fKey){
  state.turn.fortune = fKey;
  // Reset dados f√≠sicos y bot√≠n para evitar inconsistencias
  state.turn.dice = initDiceCounts();
  state.turn.chest = initDiceCounts();
  state.turn.computed = computeTurn(state.mode, state.turn.fortune, state.turn.dice);
  render();
}

function adjustDie(key, delta){
  const d = {...state.turn.dice};
  d[key] = Math.max(0, (d[key]||0) + delta);
  if (totalDice(d) > 8) return;
  state.turn.dice = d;

  // Si el usuario reduce un tipo, aseg√∫rate de que Bot√≠n no supere lo disponible
  if (state.turn.fortune === 'chest'){
    const all = mergeDice(applyFortuneBaseDice('none'), state.turn.dice); // Bot√≠n no a√±ade base; el all real se calcula en computeTurn
    // realmente Bot√≠n no da dados extra, as√≠ que podemos ajustar por el "all" real luego.
    // aqu√≠ hacemos un ‚Äúclamp suave‚Äù a nivel de dados f√≠sicos (por tipo).
    for (const k of Object.keys(state.turn.chest)){
      const maxAllowed = (state.turn.dice[k] || 0); // en bot√≠n s√≥lo permitimos marcar dados f√≠sicos (m√°s simple)
      state.turn.chest[k] = Math.min(state.turn.chest[k], maxAllowed);
    }
  }

  state.turn.computed = computeTurn(state.mode, state.turn.fortune, state.turn.dice);
  render();
}

// NUEVO: Bot√≠n como selecci√≥n por tipo (subconjunto de dados f√≠sicos)
// Para UI f√°cil, permitimos marcar hasta el n√∫mero de dados f√≠sicos de ese tipo.
// (En el juego real podr√≠as meter tambi√©n el +1 de moneda/diamante de carta en el bot√≠n, pero Bot√≠n es una carta distinta; aqu√≠ no aplica.)
function toggleChestForType(key, checked){
  if (state.turn.fortune !== 'chest') return;
  const max = state.turn.dice[key] || 0;
  state.turn.chest[key] = checked ? max : 0;
  render();
}

function setChestCount(key, val){
  if (state.turn.fortune !== 'chest') return;
  const max = state.turn.dice[key] || 0;
  const n = Math.max(0, Math.min(max, parseInt(val,10) || 0));
  state.turn.chest[key] = n;
  render();
}

function nextPlayer(){
  state.currentPlayerIndex = (state.currentPlayerIndex + 1) % state.players.length;
  if (state.currentPlayerIndex === 0) state.round += 1;
}

async function confirmDiceSelection(){
  const c = state.turn.computed;
  if (!c.canConfirm) return;

  // Isla Calavera
  if (c.canSkullIsland){
    state.screen = 'skullIsland';
    state.skullIsland.collectedSkulls = c.skullIslandBaseSkulls;
    render();
    return;
  }

  const idx = state.currentPlayerIndex;
  const player = state.players[idx];

  const fortune = state.turn.fortune;
  const physical = state.turn.dice;

  // Bot√≠n: si muere (3+ calaveras), punt√∫an s√≥lo los dados del bot√≠n [page:1].
  if (fortune === 'chest'){
    const chestSel = state.turn.chest;
    const v = validateChestSelection(physical, chestSel);
    if (!v.ok){
      await modalConfirm({title:'Bot√≠n inv√°lido', body:v.reasons.join(' '), okText:'OK', cancelText:'Cerrar'});
      return;
    }

    const allPhysical = {...physical};

    // Detectar muerte: 3+ calaveras en resultado final (en f√≠sicos, Bot√≠n no a√±ade calaveras extra)
    const bust = allPhysical.skull >= 3;

    if (bust){
      // Puntuaci√≥n SOLO de los dados del bot√≠n (sin calaveras, porque bot√≠n no deber√≠a tener calaveras √∫tiles)
      const chestDice = {...chestSel};

      // Asegurar: si el usuario marc√≥ calaveras en bot√≠n, no punt√∫an igual (no aportan nada).
      // Las dejamos, no suman nada salvo que afecten a cofre completo (que aqu√≠ no aplicar√° por skull>0).
      const chestPointsObj = computePointsFromDice(state.mode, 'none', chestDice);
      // Importante: en Bot√≠n al morir, no aplica la carta Bot√≠n como multiplicador ni barco; es ‚Äús√≥lo los dados ya colocados‚Äù [page:1].
      const gained = chestPointsObj.points;

      const ok = await modalConfirm({
        title: 'Muerte con Bot√≠n',
        body: `Has sacado 3+ calaveras. Seg√∫n Bot√≠n, s√≥lo punt√∫an los dados guardados: +${Math.trunc(gained).toLocaleString('es-ES')} puntos [page:1].`,
        okText: 'Aplicar',
        cancelText: 'Cancelar'
      });
      if (!ok) return;

      player.score = clampScore(state.mode, player.score + gained);
      // Continuar flujo normal de fin
      finishTurnAndAdvance(player);
      return;
    }

    // Si no muere, Bot√≠n no altera (en nuestro modelo ‚Äúresultado final‚Äù)
    player.score = clampScore(state.mode, player.score + c.points);
    finishTurnAndAdvance(player);
    return;
  }

  // Turno normal
  player.score = clampScore(state.mode, player.score + c.points);

  // Magia 9 dados [page:1]
  const base = applyFortuneBaseDice(fortune);
  const all = mergeDice(base, physical);
  const magicWin =
    (fortune === 'gold' && all.gold === 9) ||
    (fortune === 'diamond' && all.diamond === 9);

  if (magicWin){
    state.screen = 'finished';
    state.winnerId = player.id;
    render();
    return;
  }

  finishTurnAndAdvance(player);
}

function finishTurnAndAdvance(triggerPlayer){
  // Gestor final a 6000 (misma l√≥gica que antes, basada en regla de ‚Äú√∫ltimos abordajes‚Äù) [page:1].
  if (!state.finalPhase && triggerPlayer.score >= TARGET_SCORE){
    state.finalPhase = { triggerPlayerId: triggerPlayer.id, turnsRemaining: state.players.length - 1, leaderExtraTurn: false };
  } else if (state.finalPhase){
    if (triggerPlayer.id !== state.finalPhase.triggerPlayerId){
      state.finalPhase.turnsRemaining -= 1;
    }
  }

  // Siguiente jugador
  nextPlayer();

  // ¬øTermina final phase?
  if (state.finalPhase && state.finalPhase.turnsRemaining <= 0){
    const trigger = state.players.find(p => p.id === state.finalPhase.triggerPlayerId);
    const best = state.players.reduce((a,b)=> (b.score > a.score ? b : a), state.players[0]);

    if (best.id !== trigger.id && !state.finalPhase.leaderExtraTurn){
      state.finalPhase.leaderExtraTurn = true;
      state.currentPlayerIndex = state.players.findIndex(p => p.id === trigger.id);
      startTurn();
      return;
    }

    state.screen = 'finished';
    state.winnerId = best.id;
    render();
    return;
  }

  startTurn();
}

function adjustSkullIsland(delta){
  state.skullIsland.collectedSkulls = Math.max(0, state.skullIsland.collectedSkulls + delta);
  render();
}

async function confirmSkullIsland(){
  const idx = state.currentPlayerIndex;
  const active = state.players[idx];

  const perSkull = computeSkullIslandPenaltyPerSkull(state.turn.fortune);
  const skulls = state.skullIsland.collectedSkulls;

  const ok = await modalConfirm({
    title: 'Confirmar Isla Calavera',
    body: `Se aplicar√° una penalizaci√≥n de ${perSkull} por calavera a cada rival. Calaveras: ${skulls}.`,
    okText: 'Aplicar',
    cancelText: 'Volver'
  });
  if (!ok) return;

  for (const p of state.players){
    if (p.id === active.id) continue;
    p.score = clampScore(state.mode, p.score - perSkull * skulls);
  }

  nextPlayer();
  startTurn();
}

function setPlayerName(i, name){
  state.players[i].name = name.trim().slice(0, 24) || state.players[i].name;
}

async function confirmNames(){
  for (const p of state.players){
    if (!p.name || !p.name.trim()){
      await modalConfirm({title:'Nombre inv√°lido', body:'Todos los jugadores deben tener nombre.', okText:'OK', cancelText:'Cerrar'});
      return;
    }
  }
  beginGame();
}

function winner(){
  const w = state.players.find(p => p.id === state.winnerId);
  if (w) return w;
  return state.players.reduce((a,b)=> (b.score > a.score ? b : a), state.players[0]);
}

function render(){
  const app = document.getElementById('app');
  app.innerHTML = '';

  if (state.screen === 'setup') app.appendChild(renderSetup());
  if (state.screen === 'names') app.appendChild(renderNames());
  if (state.screen === 'turn') app.appendChild(renderTurn());
  if (state.screen === 'skullIsland') app.appendChild(renderSkullIsland());
  if (state.screen === 'finished') app.appendChild(renderFinished());
}

function renderSetup(){
  const el = document.createElement('div');
  el.className = 'grid';

  const left = document.createElement('div');
  left.className = 'card';
  left.innerHTML = `
    <h2>‚öôÔ∏è Configuraci√≥n</h2>

    <label>Modo de juego</label>
    <select id="modeSel">
      <option value="normal">Normal (no baja de 0)</option>
      <option value="hardcore">Hardcore (permite negativo)</option>
    </select>

    <label>N√∫mero de jugadores</label>
    <div class="row" style="margin-top:8px">
      <button class="btn btn-primary" data-n="2">2</button>
      <button class="btn btn-primary" data-n="3">3</button>
      <button class="btn btn-primary" data-n="4">4</button>
      <button class="btn btn-primary" data-n="5">5</button>
    </div>

    <div class="divider"></div>
    <div class="right">
      <button class="btn btn-secondary" id="goNames">Continuar</button>
    </div>
    <div style="margin-top:10px" class="notice">
      <div class="small muted">
        Objetivo est√°ndar: 6.000 puntos. Se usa 2‚Äì5 jugadores seg√∫n el juego [page:1].
      </div>
    </div>
  `;

  const right = document.createElement('div');
  right.className = 'card';
  right.innerHTML = `
    <h2>üìå Notas</h2>
    <div class="small muted">
      Versi√≥n ‚Äúresultado final‚Äù: introduces el resultado final del turno y la app calcula puntos autom√°ticamente seg√∫n reglamento [page:1].<br><br>
      Con la carta <b>Bot√≠n</b>, si mueres (3+ calaveras) punt√∫an los dados marcados como guardados [page:1].
    </div>
  `;

  el.append(left, right);

  const modeSel = left.querySelector('#modeSel');
  modeSel.value = state.mode;
  modeSel.onchange = (e) => { state.mode = e.target.value; };

  left.querySelectorAll('button[data-n]').forEach(btn => {
    btn.onclick = () => { state.numPlayers = parseInt(btn.dataset.n,10); render(); };
    if (parseInt(btn.dataset.n,10) === state.numPlayers){
      btn.style.filter = 'brightness(1.08)';
    }else{
      btn.style.filter = 'brightness(.92)';
    }
  });

  left.querySelector('#goNames').onclick = () => startNamesScreen();
  return el;
}

function renderNames(){
  const el = document.createElement('div');
  el.className = 'card';

  el.innerHTML = `
    <h2>üë• Jugadores</h2>
    <div class="small muted">Edita los nombres y confirma para empezar. El jugador inicial ser√° aleatorio.</div>
    <div class="divider"></div>
    <div id="namesGrid" class="grid"></div>
    <div class="divider"></div>
    <div class="right">
      <button class="btn btn-ghost" id="back">Volver</button>
      <button class="btn btn-secondary" id="confirm">Empezar partida</button>
    </div>
  `;

  const grid = el.querySelector('#namesGrid');
  state.players.forEach((p, i) => {
    const c = document.createElement('div');
    c.className = 'card';
    c.style.background = 'rgba(0,0,0,.22)';
    c.innerHTML = `
      <div class="pill"><span>üè¥‚Äç‚ò†Ô∏è</span><span>${i+1}</span><small>Jugador</small></div>
      <label>Nombre</label>
      <input type="text" value="${escapeHtml(p.name)}" data-i="${i}" />
      <div class="small muted" style="margin-top:8px">Puntuaci√≥n inicial: 0</div>
    `;
    c.querySelector('input').oninput = (e) => setPlayerName(i, e.target.value);
    grid.appendChild(c);
  });

  el.querySelector('#back').onclick = () => { state.screen='setup'; render(); };
  el.querySelector('#confirm').onclick = () => confirmNames();

  return el;
}

function renderScoreboard(){
  const wrap = document.createElement('div');
  wrap.className = 'card';

  const active = state.players[state.currentPlayerIndex];

  wrap.innerHTML = `
    <h2>üìä Marcador</h2>
    <div class="row" style="justify-content:space-between;align-items:center">
      <div class="pill">Ronda <b>${state.round}</b></div>
      <div class="pill">Turno de <b>${escapeHtml(active.name)}</b></div>
      <div class="pill"><small>Modo</small> ${state.mode === 'hardcore' ? 'Hardcore' : 'Normal'}</div>
    </div>
    <div class="divider"></div>
    <div class="grid" id="sb"></div>
  `;

  const sb = wrap.querySelector('#sb');
  const sorted = [...state.players].sort((a,b)=> b.score - a.score);
  for (const p of sorted){
    const c = document.createElement('div');
    c.className = 'card';
    c.style.background = 'rgba(0,0,0,.22)';
    c.innerHTML = `
      <div style="display:flex;justify-content:space-between;gap:12px;align-items:center">
        <div style="font-weight:900;color:var(--gold)">${escapeHtml(p.name)}</div>
        <div class="score">${p.score.toLocaleString('es-ES')}</div>
      </div>
    `;
    sb.appendChild(c);
  }
  return wrap;
}

function renderChestUI(){
  const wrap = document.createElement('div');
  wrap.className = 'card';
  wrap.style.background = 'rgba(0,0,0,.22)';

  const dice = state.turn.dice;
  const chest = state.turn.chest;

  const totalChest = totalDice(chest);
  wrap.innerHTML = `
    <h2>üì¶ Bot√≠n</h2>
    <div class="small muted">Marca cu√°ntos dados del resultado final estaban guardados en la carta. Si mueres (3+ calaveras), s√≥lo punt√∫an estos dados [page:1].</div>
    <div class="divider"></div>
    <div class="notice">
      <div class="kv"><span>Dados en Bot√≠n</span><b>${totalChest}/8</b></div>
      <div class="small muted">Consejo: en resultado final, normalmente marcar√°s aqu√≠ los dados ‚Äúbuenos‚Äù que quieres conservar.</div>
    </div>
    <div class="divider"></div>
    <div id="chestRows" style="display:flex;flex-direction:column;gap:10px"></div>
  `;

  const rows = wrap.querySelector('#chestRows');

  for (const t of DICE_TYPES){
    const max = dice[t.key] || 0;
    const val = chest[t.key] || 0;

    const row = document.createElement('div');
    row.className = 'checkrow';

    row.innerHTML = `
      <div class="lhs">
        <input type="checkbox" id="ch-${t.key}" ${val === max && max > 0 ? 'checked' : ''} ${max === 0 ? 'disabled' : ''}/>
        <div>
          <div style="font-weight:900">${t.emoji} ${escapeHtml(t.label)} <span class="tag">(han salido: ${max})</span></div>
          <div class="tag">En Bot√≠n: <b>${val}</b></div>
        </div>
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <input type="text" inputmode="numeric" pattern="[0-9]*" id="chv-${t.key}" value="${val}" style="width:72px;text-align:center" ${max===0?'disabled':''}/>
      </div>
    `;

    // checkbox = ‚Äútodo el tipo‚Äù o ‚Äúnada‚Äù
    const cb = row.querySelector(`#ch-${t.key}`);
    cb.onchange = (e) => toggleChestForType(t.key, e.target.checked);

    // input num√©rico
    const inp = row.querySelector(`#chv-${t.key}`);
    inp.oninput = (e) => {
      // mantenerlo num√©rico (suave)
      e.target.value = e.target.value.replace(/[^\d]/g,'');
      setChestCount(t.key, e.target.value);
    };

    rows.appendChild(row);
  }

  return wrap;
}

function renderTurn(){
  const el = document.createElement('div');
  el.className = 'grid';

  const left = document.createElement('div');
  left.className = 'card';

  const c = state.turn.computed;

  left.innerHTML = `
    <h2>üé≤ Turno</h2>

    <label>Carta de acci√≥n</label>
    <select id="fortuneSel">
      ${FORTUNE.map(f => `<option value="${f.key}">${escapeHtml(f.label)}</option>`).join('')}
    </select>

    <div class="divider"></div>

    <div class="notice ${c.bust ? 'bad' : 'good'}">
      <div class="kv"><span>Dados seleccionados</span><b>${c.totalDice}/8</b></div>
      <div class="kv"><span>Calaveras totales</span><b>${c.skullsTotal}</b></div>
      <div class="kv"><span>Puntos del turno</span><b>${Math.trunc(c.points).toLocaleString('es-ES')}</b></div>
      ${c.canSkullIsland ? `<div class="small" style="margin-top:6px"><b>Isla Calavera</b> disponible (4+ calaveras).</div>` : ''}
      ${state.turn.fortune === 'chest' && (state.turn.dice.skull >= 3) ? `<div class="small" style="margin-top:6px"><b>Muerte</b>: se aplicar√° Bot√≠n al confirmar.</div>` : ''}
    </div>

    <div style="margin-top:12px" class="right">
      <button class="btn btn-ghost" id="endToSetup">Nueva partida</button>
      <button class="btn btn-secondary" id="confirmDice" ${c.canConfirm ? '' : 'disabled'} style="filter:${c.canConfirm?'none':'grayscale(1) opacity(.65)'}">
        Confirmar dados
      </button>
    </div>

    <div class="divider"></div>
    <div class="small muted">
      ${c.notes.length ? c.notes.map(n => `‚Ä¢ ${escapeHtml(n)}`).join('<br>') : 'Selecciona carta y reparte los 8 dados.'}
    </div>
  `;

  const right = document.createElement('div');
  right.className = 'card';
  right.innerHTML = `
    <h2>üßÆ Dados (8)</h2>
    <div id="counters" style="display:flex;flex-direction:column;gap:10px"></div>
  `;

  const counters = right.querySelector('#counters');
  for (const t of DICE_TYPES){
    const val = state.turn.dice[t.key] || 0;
    const item = document.createElement('div');
    item.className = 'counter';
    item.innerHTML = `
      <div>
        <div class="name">${t.emoji} ${escapeHtml(t.label)}</div>
        <div class="sub">Seleccionados: ${val}</div>
      </div>
      <div class="ctl">
        <button class="mini" data-k="${t.key}" data-d="-1">‚àí</button>
        <div class="num">${val}</div>
        <button class="mini" data-k="${t.key}" data-d="1">+</button>
      </div>
    `;
    item.querySelectorAll('button.mini').forEach(b=>{
      b.onclick = () => adjustDie(b.dataset.k, parseInt(b.dataset.d,10));
    });
    counters.appendChild(item);
  }

  el.append(renderScoreboard(), left, right);

  // Si Bot√≠n: meter UI adicional
  if (state.turn.fortune === 'chest'){
    el.append(renderChestUI());
  }

  // bind
  const fortuneSel = left.querySelector('#fortuneSel');
  fortuneSel.value = state.turn.fortune;
  fortuneSel.onchange = (e) => setFortune(e.target.value);

  left.querySelector('#confirmDice').onclick = () => confirmDiceSelection();
  left.querySelector('#endToSetup').onclick = async () => {
    const ok = await modalConfirm({
      title:'Nueva partida',
      body:'Se perder√° la partida actual. ¬øContinuar?',
      okText:'S√≠, empezar de nuevo',
      cancelText:'Cancelar'
    });
    if (ok) resetToSetup();
  };

  return el;
}

function renderSkullIsland(){
  const el = document.createElement('div');
  el.className = 'grid';

  const left = document.createElement('div');
  left.className = 'card';
  const idx = state.currentPlayerIndex;
  const active = state.players[idx];

  const perSkull = computeSkullIslandPenaltyPerSkull(state.turn.fortune);

  left.innerHTML = `
    <h2>üíÄ Isla Calavera</h2>
    <div class="notice bad">
      <div class="kv"><span>Jugador activo</span><b>${escapeHtml(active.name)}</b></div>
      <div class="kv"><span>Penalizaci√≥n por calavera</span><b>${perSkull}</b></div>
      <div class="kv"><span>Calaveras acumuladas</span><b>${state.skullIsland.collectedSkulls}</b></div>
    </div>

    <div class="divider"></div>

    <div class="counter">
      <div>
        <div class="name">üíÄ Calaveras</div>
        <div class="sub">Ajusta el total final</div>
      </div>
      <div class="ctl">
        <button class="mini" id="skMinus">‚àí</button>
        <div class="num">${state.skullIsland.collectedSkulls}</div>
        <button class="mini" id="skPlus">+</button>
      </div>
    </div>

    <div class="divider"></div>
    <div class="right">
      <button class="btn btn-ghost" id="backTurn">Volver</button>
      <button class="btn btn-secondary" id="apply">Aplicar penalizaci√≥n</button>
    </div>

    <div class="divider"></div>
    <div class="small muted">
      En Isla Calavera el jugador no punt√∫a y los dem√°s pierden ${perSkull} por calavera (con Pirata: 200) [page:1].
    </div>
  `;

  el.append(renderScoreboard(), left);

  left.querySelector('#skMinus').onclick = () => adjustSkullIsland(-1);
  left.querySelector('#skPlus').onclick = () => adjustSkullIsland(1);
  left.querySelector('#apply').onclick = () => confirmSkullIsland();
  left.querySelector('#backTurn').onclick = () => {
    state.screen = 'turn';
    render();
  };

  return el;
}

function renderFinished(){
  const el = document.createElement('div');
  el.className = 'card';
  const w = winner();

  el.innerHTML = `
    <h2>üèÜ Fin de partida</h2>
    <div class="notice good">
      <div class="kv"><span>Ganador</span><b>${escapeHtml(w.name)}</b></div>
      <div class="kv"><span>Puntuaci√≥n</span><b>${w.score.toLocaleString('es-ES')}</b></div>
    </div>
    <div class="divider"></div>
    <div class="right">
      <button class="btn btn-primary" id="new">Nueva partida</button>
    </div>
    <div class="divider"></div>
    <div class="small muted">El final se gestiona con la regla de 6.000 y turnos finales seg√∫n reglamento [page:1].</div>
  `;

  el.appendChild(renderScoreboard());

  el.querySelector('#new').onclick = () => resetToSetup();
  return el;
}

// Init
resetToSetup();
</script>
</body>
</html>
